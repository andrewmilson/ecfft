#![feature(array_windows, array_chunks, once_cell)]

pub mod ec;
pub mod ecfft;
pub mod schoofs;
mod utils;

use ark_ff::PrimeField;
use ec::Curve;
use ec::Point;

/// The interface for fields that are able to be used in ECFFTs.
trait EcFftField: PrimeField {
    /// Generator of the largest subgroup.
    const COSET_OFFSET: Point<Self>;

    /// Generator of a subgroup of order 2^k
    const SUBGROUP_GENERATOR: Point<Self>;

    /// Let `N` be the order of the subgroup generated by `SUBGROUP_GENERATOR`.
    /// Then `TWO_ADICITY` is the two-adicity of `N`, i.e. the integer `k`
    /// such that `N = 2^k`.
    const SUBGORUP_TWO_ADDICITY: u32;

    /// Returns an FFTree that's capable of evaluating polynomials up
    /// to degree n-1. Returns None if no such FFTree for this config exists.
    /// Panics if n is not a power of two.
    fn build_fftree(n: usize) -> Option<ecfft::FFTree<Self>> {
        assert!(n.is_power_of_two());
        let log_n = n.ilog2();
        if log_n > Self::SUBGORUP_TWO_ADDICITY {
            return None;
        }

        let mut generator = Self::SUBGROUP_GENERATOR;
        for _ in 0..Self::SUBGORUP_TWO_ADDICITY - log_n {
            generator += generator;
        }

        Some(ecfft::FFTree::new(Self::COSET_OFFSET, generator))
    }
}

mod secp256k1 {
    use super::*;
    use ark_ff::Fp256;
    use ark_ff::MontBackend;
    use ark_ff::MontConfig;
    use ark_ff::MontFp as Fp;

    /// Secp256k1 field
    #[derive(MontConfig)]
    #[modulus = "115792089237316195423570985008687907853269984665640564039457584007908834671663"]
    #[generator = "3"]
    #[small_subgroup_base = "3"]
    #[small_subgroup_power = "1"]
    pub struct FqConfig;
    pub type Fp = Fp256<MontBackend<FqConfig, 4>>;

    /// Curve with 2^21 | #E
    const CURVE: Curve<Fp> = Curve::new(
        Fp!("17748197196278671983710270881246356270498036375776972586378254349879758261964"),
        Fp!("48180245521382520283744586749255972002017879486304201780206317812189781697357"),
    );

    impl EcFftField for Fp {
        const COSET_OFFSET: Point<Self> = Point::new(
            Fp!("115586231547899789830608385860912259025927156426918763229928961975571719340855"),
            Fp!("70390068299898099747397252552195472490177603500858519188131399005432093509871"),
            CURVE,
        );

        const SUBGROUP_GENERATOR: Point<Self> = Point::new(
            Fp!("23561735202437581205271378497680111566519991508173489172095082128876671442116"),
            Fp!("84964696387510691827760857554228718714431485321484523373785277466595465928698"),
            CURVE,
        );

        const SUBGORUP_TWO_ADDICITY: u32 = 20;
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use ark_poly::univariate::DensePolynomial;
        use ark_poly::DenseUVPolynomial;
        use ark_poly::Polynomial;
        use rand::rngs::StdRng;
        use rand::SeedableRng;
        use std::sync::OnceLock;

        static FFTREE: OnceLock<ecfft::FFTree<Fp>> = OnceLock::new();

        #[test]
        fn evaluates_polynomial() {
            let n = 64;
            let fftree = FFTREE.get_or_init(|| Fp::build_fftree(n).unwrap());
            let mut rng = StdRng::from_seed([1; 32]);
            let poly = DensePolynomial::rand(n - 1, &mut rng);
            let eval_domain = fftree.eval_domain(n);

            let ecfft_evals = fftree.enter(&poly);

            let expected_evals: Vec<Fp> = eval_domain.iter().map(|x| poly.evaluate(x)).collect();
            assert_eq!(expected_evals, ecfft_evals);
        }
    }
}

mod m31 {
    use super::*;
    use ark_ff_optimized::fp31::Fp;

    /// Supersingular curve with 2^31 | #E
    const CURVE: Curve<Fp> = Curve::new(Fp(1), Fp(0));

    impl EcFftField for Fp {
        const COSET_OFFSET: Point<Self> = Point::new(Fp(1048755163), Fp(279503108), CURVE);
        const SUBGROUP_GENERATOR: Point<Self> = Point::new(Fp(1273083559), Fp(804329170), CURVE);
        const SUBGORUP_TWO_ADDICITY: u32 = 28;
    }

    // TODO: there's a lot of repetition between field tests. Should implement macro
    // or loop at solutions to remove duplication of test logic.
    #[cfg(test)]
    mod tests {
        use super::*;
        use ark_poly::univariate::DensePolynomial;
        use ark_poly::DenseUVPolynomial;
        use ark_poly::Polynomial;
        use rand::rngs::StdRng;
        use rand::SeedableRng;
        use std::sync::OnceLock;

        static FFTREE: OnceLock<ecfft::FFTree<Fp>> = OnceLock::new();

        #[test]
        fn evaluates_polynomial() {
            let n = 64;
            let fftree = FFTREE.get_or_init(|| Fp::build_fftree(n).unwrap());
            let mut rng = StdRng::from_seed([1; 32]);
            let poly = DensePolynomial::rand(n - 1, &mut rng);
            let eval_domain = fftree.eval_domain(n);

            let ecfft_evals = fftree.enter(&poly);

            let expected_evals: Vec<Fp> = eval_domain.iter().map(|x| poly.evaluate(x)).collect();
            assert_eq!(expected_evals, ecfft_evals);
        }
    }
}
